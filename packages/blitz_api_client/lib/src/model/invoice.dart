//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//

import 'package:blitz_api_client/src/model/features_entry.dart';
import 'package:blitz_api_client/src/model/invoice_htlc.dart';
import 'package:blitz_api_client/src/model/invoice_state.dart';
import 'package:blitz_api_client/src/model/route_hint.dart';
import 'package:built_collection/built_collection.dart';
import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';

part 'invoice.g.dart';

/// Invoice
///
/// Properties:
/// * [memo] - Optional memo to attach along with the invoice. Used for record keeping purposes for the invoice's creator,         and will also be set in the description field of the encoded payment request if the description_hash field is not being used.
/// * [rPreimage] - The hex-encoded preimage(32 byte) which will allow settling an incoming HTLC payable to this preimage.
/// * [rHash] - The hash of the preimage.
/// * [valueMsat] - The value of this invoice in milli satoshis.
/// * [settled] - Whether this invoice has been fulfilled
/// * [creationDate] - When this invoice was created. Not available with CLN.
/// * [settleDate] - When this invoice was settled. Not available with pending invoices.
/// * [expiryDate] - The time at which this invoice expires
/// * [paymentRequest] - A bare-bones invoice for a payment within the     Lightning Network. With the details of the invoice, the sender has all the data necessary to     send a payment to the recipient.
/// * [descriptionHash] -      Hash(SHA-256) of a description of the payment. Used if the description of payment(memo) is too     long to naturally fit within the description field of an encoded payment request.
/// * [expiry] - Payment request expiry time in seconds. Default is 3600 (1 hour).
/// * [fallbackAddr] - Fallback on-chain address.
/// * [cltvExpiry] - Delta to use for the time-lock of the CLTV extended to the final hop.
/// * [routeHints] -      Route hints that can each be individually used to assist in reaching the invoice's destination.
/// * [private] - Whether this invoice should include routing hints for private channels.
/// * [addIndex] -  The index of this invoice. Each newly created invoice will increment this index making it monotonically increasing. CLN and LND handle ids differently. LND will generate an auto incremented integer id, while CLN will use a user supplied string id. To unify both, we auto generate an id for CLN and use the add_index for LND.  For `LND` this will be an `integer` in string form. This is auto generated by LND.  For `CLN` this will be a `string`. If the invoice was generated by BlitzAPI, this will be a [Firebase-like PushID](https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68). If generated by some other method, it'll be the string supplied by the user at the time of creation of the invoice.
/// * [settleIndex] -          The \"settle\" index of this invoice. Each newly settled invoice will  increment this index making it monotonically increasing.
/// * [amtPaidSat] -      The amount that was accepted for this invoice, in satoshis. This     will ONLY be set if this invoice has been settled. We provide     this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted.     Additionally, it's possible that the sender paid MORE that     was specified in the original invoice. So we'll record that here as well.
/// * [amtPaidMsat] -      The amount that was accepted for this invoice, in millisatoshis.     This will ONLY be set if this invoice has been settled. We     provide this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted. Additionally,     it's possible that the sender paid MORE that was specified in the     original invoice. So we'll record that here as well.
/// * [state] - The state the invoice is in.
/// * [htlcs] - List of HTLCs paying to this invoice[EXPERIMENTAL].
/// * [features] - List of features advertised on the invoice.
/// * [isKeysend] - [LND only] Indicates if this invoice was a spontaneous payment that arrived via keysend[EXPERIMENTAL].
/// * [paymentAddr] -  The payment address of this invoice. This value will be used in MPP payments,     and also for newer invoices that always require the MPP payload for added end-to-end security.
/// * [isAmp] - Signals whether or not this is an AMP invoice.
abstract class Invoice implements Built<Invoice, InvoiceBuilder> {
  /// Optional memo to attach along with the invoice. Used for record keeping purposes for the invoice's creator,         and will also be set in the description field of the encoded payment request if the description_hash field is not being used.
  @BuiltValueField(wireName: r'memo')
  String? get memo;

  /// The hex-encoded preimage(32 byte) which will allow settling an incoming HTLC payable to this preimage.
  @BuiltValueField(wireName: r'r_preimage')
  String? get rPreimage;

  /// The hash of the preimage.
  @BuiltValueField(wireName: r'r_hash')
  String? get rHash;

  /// The value of this invoice in milli satoshis.
  @BuiltValueField(wireName: r'value_msat')
  int get valueMsat;

  /// Whether this invoice has been fulfilled
  @BuiltValueField(wireName: r'settled')
  bool? get settled;

  /// When this invoice was created. Not available with CLN.
  @BuiltValueField(wireName: r'creation_date')
  int? get creationDate;

  /// When this invoice was settled. Not available with pending invoices.
  @BuiltValueField(wireName: r'settle_date')
  int? get settleDate;

  /// The time at which this invoice expires
  @BuiltValueField(wireName: r'expiry_date')
  int? get expiryDate;

  /// A bare-bones invoice for a payment within the     Lightning Network. With the details of the invoice, the sender has all the data necessary to     send a payment to the recipient.
  @BuiltValueField(wireName: r'payment_request')
  String? get paymentRequest;

  ///      Hash(SHA-256) of a description of the payment. Used if the description of payment(memo) is too     long to naturally fit within the description field of an encoded payment request.
  @BuiltValueField(wireName: r'description_hash')
  String? get descriptionHash;

  /// Payment request expiry time in seconds. Default is 3600 (1 hour).
  @BuiltValueField(wireName: r'expiry')
  int? get expiry;

  /// Fallback on-chain address.
  @BuiltValueField(wireName: r'fallback_addr')
  String? get fallbackAddr;

  /// Delta to use for the time-lock of the CLTV extended to the final hop.
  @BuiltValueField(wireName: r'cltv_expiry')
  int? get cltvExpiry;

  ///      Route hints that can each be individually used to assist in reaching the invoice's destination.
  @BuiltValueField(wireName: r'route_hints')
  BuiltList<RouteHint>? get routeHints;

  /// Whether this invoice should include routing hints for private channels.
  @BuiltValueField(wireName: r'private')
  bool? get private;

  ///  The index of this invoice. Each newly created invoice will increment this index making it monotonically increasing. CLN and LND handle ids differently. LND will generate an auto incremented integer id, while CLN will use a user supplied string id. To unify both, we auto generate an id for CLN and use the add_index for LND.  For `LND` this will be an `integer` in string form. This is auto generated by LND.  For `CLN` this will be a `string`. If the invoice was generated by BlitzAPI, this will be a [Firebase-like PushID](https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68). If generated by some other method, it'll be the string supplied by the user at the time of creation of the invoice.
  @BuiltValueField(wireName: r'add_index')
  String get addIndex;

  ///          The \"settle\" index of this invoice. Each newly settled invoice will  increment this index making it monotonically increasing.
  @BuiltValueField(wireName: r'settle_index')
  int? get settleIndex;

  ///      The amount that was accepted for this invoice, in satoshis. This     will ONLY be set if this invoice has been settled. We provide     this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted.     Additionally, it's possible that the sender paid MORE that     was specified in the original invoice. So we'll record that here as well.
  @BuiltValueField(wireName: r'amt_paid_sat')
  int? get amtPaidSat;

  ///      The amount that was accepted for this invoice, in millisatoshis.     This will ONLY be set if this invoice has been settled. We     provide this field as if the invoice was created with a zero value,     then we need to record what amount was ultimately accepted. Additionally,     it's possible that the sender paid MORE that was specified in the     original invoice. So we'll record that here as well.
  @BuiltValueField(wireName: r'amt_paid_msat')
  int? get amtPaidMsat;

  /// The state the invoice is in.
  @BuiltValueField(wireName: r'state')
  InvoiceState? get state;

  /// List of HTLCs paying to this invoice[EXPERIMENTAL].
  @BuiltValueField(wireName: r'htlcs')
  BuiltList<InvoiceHTLC>? get htlcs;

  /// List of features advertised on the invoice.
  @BuiltValueField(wireName: r'features')
  BuiltList<FeaturesEntry>? get features;

  /// [LND only] Indicates if this invoice was a spontaneous payment that arrived via keysend[EXPERIMENTAL].
  @BuiltValueField(wireName: r'is_keysend')
  bool? get isKeysend;

  ///  The payment address of this invoice. This value will be used in MPP payments,     and also for newer invoices that always require the MPP payload for added end-to-end security.
  @BuiltValueField(wireName: r'payment_addr')
  String? get paymentAddr;

  /// Signals whether or not this is an AMP invoice.
  @BuiltValueField(wireName: r'is_amp')
  bool? get isAmp;

  Invoice._();

  @BuiltValueHook(initializeBuilder: true)
  static void _defaults(InvoiceBuilder b) => b..settled = false;

  factory Invoice([void updates(InvoiceBuilder b)]) = _$Invoice;

  @BuiltValueSerializer(custom: true)
  static Serializer<Invoice> get serializer => _$InvoiceSerializer();
}

class _$InvoiceSerializer implements StructuredSerializer<Invoice> {
  @override
  final Iterable<Type> types = const [Invoice, _$Invoice];

  @override
  final String wireName = r'Invoice';

  @override
  Iterable<Object?> serialize(Serializers serializers, Invoice object,
      {FullType specifiedType = FullType.unspecified}) {
    final result = <Object?>[];
    if (object.memo != null) {
      result
        ..add(r'memo')
        ..add(serializers.serialize(object.memo,
            specifiedType: const FullType(String)));
    }
    if (object.rPreimage != null) {
      result
        ..add(r'r_preimage')
        ..add(serializers.serialize(object.rPreimage,
            specifiedType: const FullType(String)));
    }
    if (object.rHash != null) {
      result
        ..add(r'r_hash')
        ..add(serializers.serialize(object.rHash,
            specifiedType: const FullType(String)));
    }
    result
      ..add(r'value_msat')
      ..add(serializers.serialize(object.valueMsat,
          specifiedType: const FullType(int)));
    if (object.settled != null) {
      result
        ..add(r'settled')
        ..add(serializers.serialize(object.settled,
            specifiedType: const FullType(bool)));
    }
    if (object.creationDate != null) {
      result
        ..add(r'creation_date')
        ..add(serializers.serialize(object.creationDate,
            specifiedType: const FullType(int)));
    }
    if (object.settleDate != null) {
      result
        ..add(r'settle_date')
        ..add(serializers.serialize(object.settleDate,
            specifiedType: const FullType(int)));
    }
    if (object.expiryDate != null) {
      result
        ..add(r'expiry_date')
        ..add(serializers.serialize(object.expiryDate,
            specifiedType: const FullType(int)));
    }
    if (object.paymentRequest != null) {
      result
        ..add(r'payment_request')
        ..add(serializers.serialize(object.paymentRequest,
            specifiedType: const FullType(String)));
    }
    if (object.descriptionHash != null) {
      result
        ..add(r'description_hash')
        ..add(serializers.serialize(object.descriptionHash,
            specifiedType: const FullType(String)));
    }
    if (object.expiry != null) {
      result
        ..add(r'expiry')
        ..add(serializers.serialize(object.expiry,
            specifiedType: const FullType(int)));
    }
    if (object.fallbackAddr != null) {
      result
        ..add(r'fallback_addr')
        ..add(serializers.serialize(object.fallbackAddr,
            specifiedType: const FullType(String)));
    }
    if (object.cltvExpiry != null) {
      result
        ..add(r'cltv_expiry')
        ..add(serializers.serialize(object.cltvExpiry,
            specifiedType: const FullType(int)));
    }
    if (object.routeHints != null) {
      result
        ..add(r'route_hints')
        ..add(serializers.serialize(object.routeHints,
            specifiedType: const FullType(BuiltList, [FullType(RouteHint)])));
    }
    if (object.private != null) {
      result
        ..add(r'private')
        ..add(serializers.serialize(object.private,
            specifiedType: const FullType(bool)));
    }
    result
      ..add(r'add_index')
      ..add(serializers.serialize(object.addIndex,
          specifiedType: const FullType(String)));
    if (object.settleIndex != null) {
      result
        ..add(r'settle_index')
        ..add(serializers.serialize(object.settleIndex,
            specifiedType: const FullType(int)));
    }
    if (object.amtPaidSat != null) {
      result
        ..add(r'amt_paid_sat')
        ..add(serializers.serialize(object.amtPaidSat,
            specifiedType: const FullType(int)));
    }
    if (object.amtPaidMsat != null) {
      result
        ..add(r'amt_paid_msat')
        ..add(serializers.serialize(object.amtPaidMsat,
            specifiedType: const FullType(int)));
    }
    result
      ..add(r'state')
      ..add(object.state == null
          ? null
          : serializers.serialize(object.state,
              specifiedType: const FullType.nullable(InvoiceState)));
    if (object.htlcs != null) {
      result
        ..add(r'htlcs')
        ..add(serializers.serialize(object.htlcs,
            specifiedType: const FullType(BuiltList, [FullType(InvoiceHTLC)])));
    }
    if (object.features != null) {
      result
        ..add(r'features')
        ..add(serializers.serialize(object.features,
            specifiedType:
                const FullType(BuiltList, [FullType(FeaturesEntry)])));
    }
    if (object.isKeysend != null) {
      result
        ..add(r'is_keysend')
        ..add(serializers.serialize(object.isKeysend,
            specifiedType: const FullType(bool)));
    }
    if (object.paymentAddr != null) {
      result
        ..add(r'payment_addr')
        ..add(serializers.serialize(object.paymentAddr,
            specifiedType: const FullType(String)));
    }
    if (object.isAmp != null) {
      result
        ..add(r'is_amp')
        ..add(serializers.serialize(object.isAmp,
            specifiedType: const FullType(bool)));
    }
    return result;
  }

  @override
  Invoice deserialize(Serializers serializers, Iterable<Object?> serialized,
      {FullType specifiedType = FullType.unspecified}) {
    final result = InvoiceBuilder();

    final iterator = serialized.iterator;
    while (iterator.moveNext()) {
      final key = iterator.current as String;
      iterator.moveNext();
      final Object? value = iterator.current;

      switch (key) {
        case r'memo':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.memo = valueDes;
          break;
        case r'r_preimage':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.rPreimage = valueDes;
          break;
        case r'r_hash':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.rHash = valueDes;
          break;
        case r'value_msat':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.valueMsat = valueDes;
          break;
        case r'settled':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          result.settled = valueDes;
          break;
        case r'creation_date':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.creationDate = valueDes;
          break;
        case r'settle_date':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.settleDate = valueDes;
          break;
        case r'expiry_date':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.expiryDate = valueDes;
          break;
        case r'payment_request':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.paymentRequest = valueDes;
          break;
        case r'description_hash':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.descriptionHash = valueDes;
          break;
        case r'expiry':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.expiry = valueDes;
          break;
        case r'fallback_addr':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.fallbackAddr = valueDes;
          break;
        case r'cltv_expiry':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.cltvExpiry = valueDes;
          break;
        case r'route_hints':
          final valueDes = serializers.deserialize(value,
                  specifiedType:
                      const FullType(BuiltList, [FullType(RouteHint)]))
              as BuiltList<RouteHint>;
          result.routeHints.replace(valueDes);
          break;
        case r'private':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          result.private = valueDes;
          break;
        case r'add_index':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.addIndex = valueDes;
          break;
        case r'settle_index':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.settleIndex = valueDes;
          break;
        case r'amt_paid_sat':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.amtPaidSat = valueDes;
          break;
        case r'amt_paid_msat':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(int)) as int;
          result.amtPaidMsat = valueDes;
          break;
        case r'state':
          final valueDes = serializers.deserialize(value,
                  specifiedType: const FullType.nullable(InvoiceState))
              as InvoiceState?;
          if (valueDes == null) continue;
          result.state = valueDes;
          break;
        case r'htlcs':
          final valueDes = serializers.deserialize(value,
                  specifiedType:
                      const FullType(BuiltList, [FullType(InvoiceHTLC)]))
              as BuiltList<InvoiceHTLC>;
          result.htlcs.replace(valueDes);
          break;
        case r'features':
          final valueDes = serializers.deserialize(value,
                  specifiedType:
                      const FullType(BuiltList, [FullType(FeaturesEntry)]))
              as BuiltList<FeaturesEntry>;
          result.features.replace(valueDes);
          break;
        case r'is_keysend':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          result.isKeysend = valueDes;
          break;
        case r'payment_addr':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(String)) as String;
          result.paymentAddr = valueDes;
          break;
        case r'is_amp':
          final valueDes = serializers.deserialize(value,
              specifiedType: const FullType(bool)) as bool;
          result.isAmp = valueDes;
          break;
      }
    }
    return result.build();
  }
}
